<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holistic Camera</title>
    <style>
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        .input_video, .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #calorieCount {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(110, 110, 110, 0.7); /* Added some transparency */
            padding: 10px;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            z-index: 10;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>
<div class="container">
    <video class="input_video"></video>
    <canvas class="output_canvas"></canvas>
    <div id="calorieCount"><img src="fire.png" alt="Calories burned" width="30px" height="30px"> 0 kcal</div>
</div>

<script type="module">
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const controls = window;
    const mpHolistic = window;
    const drawingUtils = window;

    let cumulativeCalories = 0; // To hold the cumulative calorie count
    let lastCalorieCount = 0; // To hold the last displayed calorie count

    navigator.getWebcam = (navigator.getUserMedia || navigator.webKitGetUserMedia || navigator.moxGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
    if (navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({  audio: true, video: true })
        .then(function (stream) {
                    //Display the video stream in the video object
        })
        .catch(function (e) { logError(e.name + ": " + e.message); });
    }
    else {
    navigator.getWebcam({ audio: true, video: true }, 
        function (stream) {
                //Display the video stream in the video object
        }, 
        function () { logError("Web cam is not accessible."); });
    }

    function onResults(results) {
        // Check if the segmentation mask is available before drawing
        if (results.segmentationMask) {
                canvasCtx.drawImage(results.segmentationMask, 0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.globalCompositeOperation = 'source-in';
                //canvasCtx.fillStyle = '#00FF007F';
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.globalCompositeOperation = 'destination-atop';
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                // Reset to default composite operation before drawing landmarks.
                canvasCtx.globalCompositeOperation = 'source-over';
            }
            // Draw Landmarks here...
            if(results.poseLandmarks) {
                drawingUtils.drawConnectors(canvasCtx, results.poseLandmarks, mpHolistic.POSE_CONNECTIONS, { color: 'white' });
                drawingUtils.drawLandmarks(canvasCtx, Object.values(mpHolistic.POSE_LANDMARKS_LEFT)
                    .map(index => results.poseLandmarks[index]), { visibilityMin: 0.65, color: 'white', fillColor: 'rgb(255,138,0)' });
                drawingUtils.drawLandmarks(canvasCtx, Object.values(mpHolistic.POSE_LANDMARKS_RIGHT)
                    .map(index => results.poseLandmarks[index]), { visibilityMin: 0.65, color: 'white', fillColor: 'rgb(0,217,231)' });
            }
            // Hands...
            if(results.rightHandLandmarks) {
                drawingUtils.drawConnectors(canvasCtx, results.rightHandLandmarks, mpHolistic.HAND_CONNECTIONS, { color: 'white' , lineWidth: 1});
                drawingUtils.drawLandmarks(canvasCtx, results.rightHandLandmarks, {
                    color: 'white',
                    fillColor: 'rgb(0,217,231)',
                    lineWidth: 1,
                    radius: (data) => {
                        return drawingUtils.lerp(data.from.z, -0.15, .1, 10, 1);
                    }
                });
            }
            if(results.leftHandLandmarks) {
                drawingUtils.drawConnectors(canvasCtx, results.leftHandLandmarks, mpHolistic.HAND_CONNECTIONS, { color: 'white' , lineWidth:1});
                drawingUtils.drawLandmarks(canvasCtx, results.leftHandLandmarks, {
                    color: 'white',
                    fillColor: 'rgb(255,138,0)',
                    lineWidth: 1,
                    radius: (data) => {
                        return drawingUtils.lerp(data.from.z, -0.15, .1, 10, 1);
                    }
                });
            }
            // Face...
            if(results.faceLandmarks) {
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_RIGHT_EYE, { color: 'rgb(0,217,231)' });
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_RIGHT_EYEBROW, { color: 'rgb(0,217,231)' });
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_LEFT_EYE, { color: 'rgb(255,138,0)' });
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_LEFT_EYEBROW, { color: 'rgb(255,138,0)' });
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_FACE_OVAL, { color: '#E0E0E0', lineWidth: 1 });
                drawingUtils.drawConnectors(canvasCtx, results.faceLandmarks, mpHolistic.FACEMESH_LIPS, { color: '#E0E0E0', lineWidth: 1 });
            }
            canvasCtx.restore();
        

        const keypoints = results.poseLandmarks;
        if (keypoints) {
            fetch('/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({keypoints})
            })
            .then(response => response.json())
            .then(data => {
                cumulativeCalories += Math.round(data.calories_burned); // Updating cumulativeCalories with newly burned calories
                // Only update the displayed calorie count if it's different from the last displayed count
                if (lastCalorieCount !== cumulativeCalories) {
                    document.getElementById('calorieCount').innerHTML = `<img src="fire.png" alt="Calories burned" width="30px" height="30px"> ${cumulativeCalories} kcal`;
                    lastCalorieCount = cumulativeCalories; // Updating last displayed calorie count
                }
            });
        }
    }



    const holistic = new Holistic({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
    }});
    holistic.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: true,
        smoothSegmentation: true,
        refineFaceLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    holistic.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await holistic.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();
</script>
</body>
</html>

